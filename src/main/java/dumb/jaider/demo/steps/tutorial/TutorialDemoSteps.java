package dumb.jaider.demo.steps.tutorial;

import dev.langchain4j.model.chat.ChatModel;
import dev.langchain4j.model.googleai.GoogleAiGeminiChatModel;
import dumb.jaider.core.DemoContext;
import dumb.jaider.core.DemoStep;
import dumb.jaider.core.workflows.CodeGenerationWorkflow;
import dumb.jaider.ui.TUI;
import dumb.jaider.utils.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.CompletableFuture;

public class TutorialDemoSteps {

    private static final Logger logger = LoggerFactory.getLogger(TutorialDemoSteps.class);
    private static final String DEFAULT_GEMINI_MODEL_NAME = "gemini-pro";

    // DisplayMessageStep is reused from dumb.jaider.demo.steps.interactive.InteractiveDemoSteps.DisplayMessageStep

    /**
     * A DemoStep that initializes the Language Model (ChatModel) for the tutorial.
     * It specifically prompts for a Gemini API key and creates a Gemini ChatModel instance.
     * This step demonstrates how a specific LLM can be configured and made available for subsequent steps.
     *
     * Expects: Nothing from DemoContext.
     * Puts:
     *   - "chatModel" (ChatModel): The initialized LangChain4j ChatModel instance (Gemini).
     */
    public static class TutorialInitializeLLMStep implements DemoStep {
        @Override
        public boolean execute(TUI tui, CodeGenerationWorkflow workflow, DemoContext context) throws Exception {
            // Inform the user about the need for an API key.
            tui.showModalMessage("Language Model Setup",
                    "This tutorial uses the Gemini language model directly via LangChain4j for code generation.\n" +
                    "Jaider needs your Google AI Gemini API Key to proceed.");

            // Prompt the user for their Gemini API Key.
            CompletableFuture<String> apiKeyFuture = tui.getUserInput("Gemini API Key Required",
                    "Please enter your Google AI Gemini API Key:", "");
            String apiKey = apiKeyFuture.join(); // Wait for user input.

            // Validate the API key.
            if (apiKey == null || apiKey.trim().isEmpty()) {
                tui.showModalMessage("API Key Error",
                        "A Gemini API Key is essential for this tutorial to interact with the language model.\n" +
                        "The demo cannot continue without it.");
                logger.warn("User did not provide a Gemini API key.");
                return false; // Stop demo flow if API key is missing.
            }

            try {
                // Initialize the Gemini ChatModel using the provided API key.
                // This demonstrates direct integration with an LLM service.
                ChatModel chatModel = GoogleAiGeminiChatModel.builder()
                        .modelName(DEFAULT_GEMINI_MODEL_NAME)
                        .apiKey(apiKey)
                        .build();
                // Store the initialized ChatModel in DemoContext for use in later steps.
                context.put("chatModel", chatModel);

                tui.showModalMessage("Language Model Ready",
                        "Successfully initialized the Gemini language model (" + DEFAULT_GEMINI_MODEL_NAME + ").\n" +
                        "Ready to proceed with code generation.");
                logger.info("Gemini ChatModel initialized successfully.");
                return true;
            } catch (Exception e) {
                // Handle potential errors during ChatModel initialization.
                logger.error("Failed to initialize Gemini ChatModel: {}", e.getMessage(), e);
                tui.showModalMessage("Language Model Error",
                        "Failed to initialize the Gemini language model. Please check your API key and network connection.\n" +
                        "Error details: " + e.getMessage());
                return false;
            }
        }
    }

    /**
     * A DemoStep that generates a single-file project based on user description using the initialized ChatModel.
     * This demonstrates Jaider's core capability of code generation from a prompt.
     * It handles temporary directory setup, LLM interaction, and displays the generated code.
     *
     * Expects from DemoContext:
     *   - "chatModel" (ChatModel): The initialized ChatModel from a previous step.
     * Puts into DemoContext:
     *   - "generatedCode" (String): The code generated by the Language Model.
     *   - "projectDescription" (String): The user-provided project description (though not explicitly put, it's retrieved and used).
     */
    public static class TutorialGenerateProjectStep implements DemoStep {
        private Path temporaryDirectoryPath; // Manages the temporary directory for this step.
        private Path generatedFilePath;      // Path to the file where generated code is saved.

        @Override
        public boolean execute(TUI tui, CodeGenerationWorkflow workflow, DemoContext context) throws Exception {
            // Retrieve the initialized ChatModel from the DemoContext.
            ChatModel chatModel = (ChatModel) context.get("chatModel");
            if (chatModel == null) {
                tui.showModalMessage("Error: Missing Language Model",
                        "The Language Model (ChatModel) was not found in the context.\n" +
                        "Please ensure the Language Model initialization step ran successfully before this step.");
                logger.error("ChatModel not found in context for TutorialGenerateProjectStep.");
                return false; // Critical dependency missing.
            }

            // Prompt the user for a project description.
            CompletableFuture<String> descriptionFuture = tui.getUserInput("Project Description",
                    "Enter a short description for a simple, single-file project Jaider should generate (e.g., 'a Python script that prints hello world'):",
                    "");
            String projectDescription = descriptionFuture.join(); // Wait for user input.
            context.put("projectDescription", projectDescription); // Store for reference if needed

            // Validate the project description.
            if (projectDescription == null || projectDescription.trim().isEmpty()) {
                tui.showModalMessage("Input Error: Empty Description", "The project description cannot be empty. Please provide some details for code generation.");
                logger.warn("User provided an empty project description.");
                return false;
            }

            try {
                // Set up a temporary directory for storing the generated file.
                setupTemporaryDirectory(tui);

                // Infer the programming language from the description for better prompt engineering (simplified).
                String language = inferLanguage(projectDescription);
                String fileName = "generated_project." + (language.equals("python") ? "py" : (language.equals("java") ? "java" : "txt"));

                // Construct the prompt to send to the Language Model.
                String prompt = String.format(
                    "Generate a simple, single-file %s project based on the description: \"%s\". " +
                    "The code should be complete and runnable if applicable. Output only the code for this single file.",
                    language, projectDescription
                );

                tui.showModalMessage("Generating Code...",
                        "Sending request to the Language Model with your project description: '" + projectDescription + "'. Please wait.");

                // Interact with the ChatModel to generate code.
                String generatedCode = chatModel.generate(prompt);
                // Store the raw generated code in DemoContext.
                context.put("generatedCode", generatedCode);

                // Check if the Language Model returned any code.
                if (generatedCode == null || generatedCode.trim().isEmpty()) {
                    tui.showModalMessage("Language Model Error",
                            "The Language Model returned an empty or null response. This might be due to content filters, a very vague prompt, or an issue with the LLM service.");
                    logger.error("LLM returned empty or null code for description: {}", projectDescription);
                    return false;
                }

                // Save the generated code to the temporary file.
                generatedFilePath = temporaryDirectoryPath.resolve(fileName);
                Files.writeString(generatedFilePath, generatedCode);
                logger.info("Generated code successfully written to: {}", generatedFilePath);

                // Display success message and the generated code to the user.
                String successMessage = "Code generated successfully by the Language Model!\n\n" +
                                        "File created at: " + generatedFilePath.toString();
                tui.showModalMessage("Code Generation Complete", successMessage);
                tui.showScrollableText("Generated Code: " + fileName, generatedCode);

                return true; // Step completed successfully.
            } catch (Exception e) {
                logger.error("Error during project generation: {}", e.getMessage(), e);
                tui.showModalMessage("Code Generation Error",
                        "An unexpected error occurred while Jaider was generating the code: " + e.getMessage() +
                        "\nCheck the logs for more details.");
                return false;
            } finally {
                cleanupTemporaryDirectory(tui);
            }
        }

        private String inferLanguage(String description) {
            description = description.toLowerCase();
            if (description.contains("python") || description.contains("script")) {
                return "python";
            } else if (description.contains("java")) {
                return "java";
            } else if (description.contains("html")) {
                return "html";
            }
            // Basic default, could be improved
            logger.warn("Could not confidently infer language from description: '{}'. Defaulting to 'text'.", description);
            return "text";
        }

        private void setupTemporaryDirectory(TUI tui) throws IOException {
            temporaryDirectoryPath = Files.createTempDirectory("tutorialDemo");
            logger.info("Temporary directory created at: {}", temporaryDirectoryPath);
            // Optionally inform user via TUI, though often not necessary for temp dirs
            // tui.showModalMessage("Setup", "Temporary directory created: " + temporaryDirectoryPath.getFileName());
        }

        private void cleanupTemporaryDirectory(TUI tui) {
            if (temporaryDirectoryPath != null) {
                try {
                    FileUtils.deleteDirectory(temporaryDirectoryPath);
                    logger.info("Temporary directory cleaned up: {}", temporaryDirectoryPath);
                    // tui.showModalMessage("Cleanup", "Temporary directory cleaned up.");
                } catch (IOException e) {
                    logger.error("Failed to clean up temporary directory {}: {}", temporaryDirectoryPath, e.getMessage(), e);
                    // tui.showModalMessage("Cleanup Error", "Failed to clean up temp directory: " + e.getMessage());
                }
            }
        }
    }
}
